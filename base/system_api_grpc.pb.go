// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v3.20.1
// source: system_api.proto

package base

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// SystemServiceClient is the client API for SystemService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type SystemServiceClient interface {
	/// Get current configuration of server.
	GetConfiguration(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Configuration, error)
	/// Get list of all available frames and signals on server.
	ListSignals(ctx context.Context, in *NameSpace, opts ...grpc.CallOption) (*Frames, error)
	//*
	// Upload file using chunks (without streams), specifically useful for
	// gRPC-web which does not support Client-side streaming.
	UploadFileChunk(ctx context.Context, in *FileUploadChunkRequest, opts ...grpc.CallOption) (*FileUploadResponse, error)
	//*
	// Upload file using streams, preferred option for client with Client-side
	// streaming.
	UploadFile(ctx context.Context, opts ...grpc.CallOption) (SystemService_UploadFileClient, error)
	/// Delete a single or multiple files from server.
	BatchDeleteFiles(ctx context.Context, in *FileDescriptions, opts ...grpc.CallOption) (*Empty, error)
	/// Download a single or multiple files from server.
	BatchDownloadFiles(ctx context.Context, in *FileDescriptions, opts ...grpc.CallOption) (SystemService_BatchDownloadFilesClient, error)
	//*
	// Will not return until new configuration is tested an active, make sure
	// to set timeout to a large value. (fibex on pi > 50s).
	ReloadConfiguration(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ReloadMessage, error)
	/// Get information about server license.
	GetLicenseInfo(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*LicenseInfo, error)
	/// Set server license.
	SetLicense(ctx context.Context, in *License, opts ...grpc.CallOption) (*LicenseInfo, error)
}

type systemServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewSystemServiceClient(cc grpc.ClientConnInterface) SystemServiceClient {
	return &systemServiceClient{cc}
}

func (c *systemServiceClient) GetConfiguration(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Configuration, error) {
	out := new(Configuration)
	err := c.cc.Invoke(ctx, "/base.SystemService/GetConfiguration", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *systemServiceClient) ListSignals(ctx context.Context, in *NameSpace, opts ...grpc.CallOption) (*Frames, error) {
	out := new(Frames)
	err := c.cc.Invoke(ctx, "/base.SystemService/ListSignals", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *systemServiceClient) UploadFileChunk(ctx context.Context, in *FileUploadChunkRequest, opts ...grpc.CallOption) (*FileUploadResponse, error) {
	out := new(FileUploadResponse)
	err := c.cc.Invoke(ctx, "/base.SystemService/UploadFileChunk", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *systemServiceClient) UploadFile(ctx context.Context, opts ...grpc.CallOption) (SystemService_UploadFileClient, error) {
	stream, err := c.cc.NewStream(ctx, &SystemService_ServiceDesc.Streams[0], "/base.SystemService/UploadFile", opts...)
	if err != nil {
		return nil, err
	}
	x := &systemServiceUploadFileClient{stream}
	return x, nil
}

type SystemService_UploadFileClient interface {
	Send(*FileUploadRequest) error
	CloseAndRecv() (*FileUploadResponse, error)
	grpc.ClientStream
}

type systemServiceUploadFileClient struct {
	grpc.ClientStream
}

func (x *systemServiceUploadFileClient) Send(m *FileUploadRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *systemServiceUploadFileClient) CloseAndRecv() (*FileUploadResponse, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(FileUploadResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *systemServiceClient) BatchDeleteFiles(ctx context.Context, in *FileDescriptions, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := c.cc.Invoke(ctx, "/base.SystemService/BatchDeleteFiles", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *systemServiceClient) BatchDownloadFiles(ctx context.Context, in *FileDescriptions, opts ...grpc.CallOption) (SystemService_BatchDownloadFilesClient, error) {
	stream, err := c.cc.NewStream(ctx, &SystemService_ServiceDesc.Streams[1], "/base.SystemService/BatchDownloadFiles", opts...)
	if err != nil {
		return nil, err
	}
	x := &systemServiceBatchDownloadFilesClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type SystemService_BatchDownloadFilesClient interface {
	Recv() (*FileDownloadResponse, error)
	grpc.ClientStream
}

type systemServiceBatchDownloadFilesClient struct {
	grpc.ClientStream
}

func (x *systemServiceBatchDownloadFilesClient) Recv() (*FileDownloadResponse, error) {
	m := new(FileDownloadResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *systemServiceClient) ReloadConfiguration(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*ReloadMessage, error) {
	out := new(ReloadMessage)
	err := c.cc.Invoke(ctx, "/base.SystemService/ReloadConfiguration", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *systemServiceClient) GetLicenseInfo(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*LicenseInfo, error) {
	out := new(LicenseInfo)
	err := c.cc.Invoke(ctx, "/base.SystemService/GetLicenseInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *systemServiceClient) SetLicense(ctx context.Context, in *License, opts ...grpc.CallOption) (*LicenseInfo, error) {
	out := new(LicenseInfo)
	err := c.cc.Invoke(ctx, "/base.SystemService/SetLicense", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SystemServiceServer is the server API for SystemService service.
// All implementations must embed UnimplementedSystemServiceServer
// for forward compatibility
type SystemServiceServer interface {
	/// Get current configuration of server.
	GetConfiguration(context.Context, *Empty) (*Configuration, error)
	/// Get list of all available frames and signals on server.
	ListSignals(context.Context, *NameSpace) (*Frames, error)
	//*
	// Upload file using chunks (without streams), specifically useful for
	// gRPC-web which does not support Client-side streaming.
	UploadFileChunk(context.Context, *FileUploadChunkRequest) (*FileUploadResponse, error)
	//*
	// Upload file using streams, preferred option for client with Client-side
	// streaming.
	UploadFile(SystemService_UploadFileServer) error
	/// Delete a single or multiple files from server.
	BatchDeleteFiles(context.Context, *FileDescriptions) (*Empty, error)
	/// Download a single or multiple files from server.
	BatchDownloadFiles(*FileDescriptions, SystemService_BatchDownloadFilesServer) error
	//*
	// Will not return until new configuration is tested an active, make sure
	// to set timeout to a large value. (fibex on pi > 50s).
	ReloadConfiguration(context.Context, *Empty) (*ReloadMessage, error)
	/// Get information about server license.
	GetLicenseInfo(context.Context, *Empty) (*LicenseInfo, error)
	/// Set server license.
	SetLicense(context.Context, *License) (*LicenseInfo, error)
	mustEmbedUnimplementedSystemServiceServer()
}

// UnimplementedSystemServiceServer must be embedded to have forward compatible implementations.
type UnimplementedSystemServiceServer struct {
}

func (UnimplementedSystemServiceServer) GetConfiguration(context.Context, *Empty) (*Configuration, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetConfiguration not implemented")
}
func (UnimplementedSystemServiceServer) ListSignals(context.Context, *NameSpace) (*Frames, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListSignals not implemented")
}
func (UnimplementedSystemServiceServer) UploadFileChunk(context.Context, *FileUploadChunkRequest) (*FileUploadResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UploadFileChunk not implemented")
}
func (UnimplementedSystemServiceServer) UploadFile(SystemService_UploadFileServer) error {
	return status.Errorf(codes.Unimplemented, "method UploadFile not implemented")
}
func (UnimplementedSystemServiceServer) BatchDeleteFiles(context.Context, *FileDescriptions) (*Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BatchDeleteFiles not implemented")
}
func (UnimplementedSystemServiceServer) BatchDownloadFiles(*FileDescriptions, SystemService_BatchDownloadFilesServer) error {
	return status.Errorf(codes.Unimplemented, "method BatchDownloadFiles not implemented")
}
func (UnimplementedSystemServiceServer) ReloadConfiguration(context.Context, *Empty) (*ReloadMessage, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReloadConfiguration not implemented")
}
func (UnimplementedSystemServiceServer) GetLicenseInfo(context.Context, *Empty) (*LicenseInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetLicenseInfo not implemented")
}
func (UnimplementedSystemServiceServer) SetLicense(context.Context, *License) (*LicenseInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetLicense not implemented")
}
func (UnimplementedSystemServiceServer) mustEmbedUnimplementedSystemServiceServer() {}

// UnsafeSystemServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to SystemServiceServer will
// result in compilation errors.
type UnsafeSystemServiceServer interface {
	mustEmbedUnimplementedSystemServiceServer()
}

func RegisterSystemServiceServer(s grpc.ServiceRegistrar, srv SystemServiceServer) {
	s.RegisterService(&SystemService_ServiceDesc, srv)
}

func _SystemService_GetConfiguration_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SystemServiceServer).GetConfiguration(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/base.SystemService/GetConfiguration",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SystemServiceServer).GetConfiguration(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _SystemService_ListSignals_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NameSpace)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SystemServiceServer).ListSignals(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/base.SystemService/ListSignals",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SystemServiceServer).ListSignals(ctx, req.(*NameSpace))
	}
	return interceptor(ctx, in, info, handler)
}

func _SystemService_UploadFileChunk_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FileUploadChunkRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SystemServiceServer).UploadFileChunk(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/base.SystemService/UploadFileChunk",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SystemServiceServer).UploadFileChunk(ctx, req.(*FileUploadChunkRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SystemService_UploadFile_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(SystemServiceServer).UploadFile(&systemServiceUploadFileServer{stream})
}

type SystemService_UploadFileServer interface {
	SendAndClose(*FileUploadResponse) error
	Recv() (*FileUploadRequest, error)
	grpc.ServerStream
}

type systemServiceUploadFileServer struct {
	grpc.ServerStream
}

func (x *systemServiceUploadFileServer) SendAndClose(m *FileUploadResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *systemServiceUploadFileServer) Recv() (*FileUploadRequest, error) {
	m := new(FileUploadRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _SystemService_BatchDeleteFiles_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FileDescriptions)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SystemServiceServer).BatchDeleteFiles(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/base.SystemService/BatchDeleteFiles",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SystemServiceServer).BatchDeleteFiles(ctx, req.(*FileDescriptions))
	}
	return interceptor(ctx, in, info, handler)
}

func _SystemService_BatchDownloadFiles_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(FileDescriptions)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(SystemServiceServer).BatchDownloadFiles(m, &systemServiceBatchDownloadFilesServer{stream})
}

type SystemService_BatchDownloadFilesServer interface {
	Send(*FileDownloadResponse) error
	grpc.ServerStream
}

type systemServiceBatchDownloadFilesServer struct {
	grpc.ServerStream
}

func (x *systemServiceBatchDownloadFilesServer) Send(m *FileDownloadResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _SystemService_ReloadConfiguration_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SystemServiceServer).ReloadConfiguration(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/base.SystemService/ReloadConfiguration",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SystemServiceServer).ReloadConfiguration(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _SystemService_GetLicenseInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SystemServiceServer).GetLicenseInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/base.SystemService/GetLicenseInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SystemServiceServer).GetLicenseInfo(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _SystemService_SetLicense_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(License)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SystemServiceServer).SetLicense(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/base.SystemService/SetLicense",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SystemServiceServer).SetLicense(ctx, req.(*License))
	}
	return interceptor(ctx, in, info, handler)
}

// SystemService_ServiceDesc is the grpc.ServiceDesc for SystemService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var SystemService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "base.SystemService",
	HandlerType: (*SystemServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetConfiguration",
			Handler:    _SystemService_GetConfiguration_Handler,
		},
		{
			MethodName: "ListSignals",
			Handler:    _SystemService_ListSignals_Handler,
		},
		{
			MethodName: "UploadFileChunk",
			Handler:    _SystemService_UploadFileChunk_Handler,
		},
		{
			MethodName: "BatchDeleteFiles",
			Handler:    _SystemService_BatchDeleteFiles_Handler,
		},
		{
			MethodName: "ReloadConfiguration",
			Handler:    _SystemService_ReloadConfiguration_Handler,
		},
		{
			MethodName: "GetLicenseInfo",
			Handler:    _SystemService_GetLicenseInfo_Handler,
		},
		{
			MethodName: "SetLicense",
			Handler:    _SystemService_SetLicense_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "UploadFile",
			Handler:       _SystemService_UploadFile_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "BatchDownloadFiles",
			Handler:       _SystemService_BatchDownloadFiles_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "system_api.proto",
}
